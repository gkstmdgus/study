
## SOLID 
### 객체지향 설계의 5대 원칙
#### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
하나의 객체는 하나의 책임을 가져야 한다.

> 왜 객체에 하나의 책임을 물어야 할까?

객체 하나에 많은 책임이 있다는 것은 그만큼 많은 역할, 기능이 있다는 뜻이다. 이런 객체의 문제점은 무엇일까?
- 한 객체에 여러 기능이 있으면 그 객체의 역할이 모호해진다. 
- 여러 기능이 함께 있으니 코드가 복잡해지고 객체의 덩치도 커진다. 
- 분리가 안되므로 확장이나 수정이 힘들다.
- 코드가 길어져서 가독성이 떨어진다.
- 기능이 많아서 재사용성이 떨어진다. 

#### 2. 개방-폐쇠 원칙 (Open-Closed Principle, OCP)
클래스는 확장에는 열려 있어야 하지만 변경에 있어서는 닫혀 있어야 한다.
> 그럼 어떤 식으로 코드를 짜야하는가?

- 객체를 직접 수정하는 일은 지양해야 한다.

왜? 필요에 의해서 객체가 수정된다면 그 객체의 사용범위는 좁아질 것이다. 소수의 요구를 만족하는 객체이므로 다른 요구가 요청되면 다시 코드를 변경해야 한다. 변경사항이 있을 때마다 객체에 기능을 추가하기 보다는 공통으로 필요한 메서드를 추상화하여 다형성의 원리로 확장을 하면 객체를 직접 건들지 않고 기능 구현이 가능하다. 새로운 기능을 추가하려면 추상 클래스를 상속받아 그 기능을 구현하면되니 확장에 자유롭고 특정 기능을 제거해도 다른 기능은 문제없이 작동이 가능하다.
~~외부에서 직접 접근 불가하게 하기~~

#### 3. 리스코프 치환 원칙(Liskov Substitution Principle, LSP)
하위 클래스 인스턴스가 상위 객체 참조변수에 대입해 상위 인스턴스 역할을 하는데 문제가 없어야 한다.
> 왜?

상속은 기능의 확장이다. 상속받은 클래스는 자신의 상위 클래스의 특성을 모두 가지고 있어야 한다. 스타크래프트를 예로 들면 최고 조상 클래스에 유닛이 있고 그 아래에 마린이라는 유닛이 있다고 해보자. 마린은 유닛 클래스를 상속받아 유닛에 있어서 필수적인 요소를 물려받았을 것이고 스팀팩같은 마린의 고유 특성은 마린 클래스에서 정의했을 것이다. 이때 마린이 유닛의 역할을 못한다는 것은 말이 안되지 않은가? 어찌보면 리스코프 치환 원칙은 상속의 개념을 다시 한 번 말하는 게 아닐까 싶다. 

#### 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
클라이언트가 필요없는 기능을 가진 인터페이스에 의존해서는 안되므로 인터페이스를 작게 분리하는 것이 좋다. 
> 이유

인터페이스의 추상 메서드를 모든 구현하지 않으면 그 클래스는 객체가 될 수 없다. 그래서 필요없는 기능이 포함되어 있으면 강제로 클래스는 메서드를 구현해야 한다. 이런 절차는 불필요한 작업이므로 인터페이스를 더 작게 나눠서 필요한 기능만 사용하는 것이 좋다.

#### 5. 의존성 역전 원칙 (Dependency Inversion Principle, DIP)
고차원 클래스(추상)는 저차원(구현)에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
> 이유?

고차원은 저차원들이 공통 조상이다. 그런 고차원이 저차원에 의존한다면 저차원의 변화로 고차원에도 영향을 끼치고 결국 모든 클래스에 영향을 미친다. 하지만 저차원이 고차원에 의존한다면 아무리 저차원을 변경해도 고차원에는 유의미한 타격이 없다. 그래서 확장과 제거에 용이해진다.


### SOILD 원칙이 하고자 하는 말은?