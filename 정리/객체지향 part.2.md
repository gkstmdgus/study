## 상속
___
두 클래스를 부모와 자식으로 관계를 맺어주는 것이다. 부모 클래스를 상속받은 자식은 부모의 멤버를 사용할 수 있다. 그래서 자식의 멤버의 수는 부모의 멤버 수보다 적을수는 없다. 
- 모든 멤버를 상속받지만 생성자와 초기화 블럭은 제외된다.
- 자바는 단일 상속만 허용한다. 
#### 포함 관계
상속관계는 아니지만 클래스의 멤버로 참조변수를 선언하는 것이다. 기능별로 클래스를 만들어놓고 이들을 객체로 생성해서 조합한다. 
#### Object
모든 클래스는 Object의 자손 클래스다. 클래스를 생성할 때 extends Object를 선언하지 않아도 컴파일러가 자동으로 선언해준다. 

&nbsp;
## 오버라이딩
___
상속받은 조상의 메서드를 변경하는 것을 오버라이딩이라고 한다. 
- 선언부를 변경하는 것은 불가능하다.
- 즉, 메서드의 내용만 변경이 가능하다.
- 접근 제어자와 예외는 제한된 조건하에 변경이 가능하다.
	- 접근 제어자는 조상 클래스보다 좁게는 변경이 불가능하다.
	- 조상보다 더 많은 예외를 선언할 수 없다.

* (?) 선언부를 변경하는 것은 불가능하다.

선언부를 변경하면 다른 메서드가 되어버리기 때문에 오버라이드가 아닌 그냥 메서드를 선언하는 것과 같다.
``` java
class Parent {  
    void testMethod(int num){  
        System.out.println("Parent class");  
    }  
}  
  
class Child extends Parent{  
    @Override  
	void testMethod(int num) {  
	    System.out.println("Test class");  
	}
}
```
위의 예시는 상속을 받고 testMethod 메서드를 오버라이딩 한 구문이다. 
``` java
class Parent {  
    void testMethod(int num){  
        System.out.println("Parent class");  
    }  
}  
  
class Child extends Parent{  
    void testMethod(){  
        System.out.println("Test class");  
    }  
}
```

위와 같이 자손 클래스에서 오버라이딩 한 메서드의 선언부를 변경하면 오류는 안나지만 오버라이딩이 아닌 일반 메서드를 선언한 것이 된다. 
``` java
class Main {  
    public static void main(String[] args) {  
        Parent parent = new Child();  
        Child child = new Child();  
        parent.testMethod(1);  
        child.testMethod(1);  
        child.testMethod();  
    }  
}
// Parent class
// Parent class
// Test class
```

그래서 오버라이딩은 선언부를 변경하면 안되고 내용만 변경이 가능하다. 

&nbsp;
## super
___

조상의 멤버와 자신의 멤버를 구별할 때 사용한다. 조상 클래스와 자손 클래스에 같은 변수명이 존재할 때 확실하게 지칭하기 위해서 `super.변수명`을 사용한다. 

#### super()
조상의 생성자를 호출할 때 사용한다. 생성자에 this()나 super()가 없으면 첫 줄에 자동으로 `super();`를 생성한다. 그래서 인스턴스를 생성하면 생성자의 super()를 거쳐서 Object 클래스까지 올라간 뒤 다시 자손 클래스로 내려온다.
&nbsp;
**주의할 점**
> 조상 클래스에 기본 생성자가 아닌 생성자만 선언하면 상속의 과정에서 오류가 발생할 가능성이 있다.

위에서 언급했듯이 생성자에서 super()를 언급하지 않으면 자동적으로 첫 줄에 super()입력해서 작동한다. 이때 super()는 조상의 기본 생성자를 호출하는 구문인데 조상에 기본 생성자가 없으니 오류가 발생하는 것이다. 만약 생성자가 하나도 없다면 컴파일러에서 자동으로 기본 생성자를 입력해주지만 생성자가 존재한다면 입력해주지 않으므로 기본 생성자를 수동으로 입력줘야 한다.
```java
class Parent {  
}  
  
class Child extends Parent{  
    Child(){  
        // 아무 입력이 없으면 super(); 자동 입력  
    }  
}
```
Parent에 기본 생성자를 입력하지 않았지만 생성자가 하나도 없으므로 자동으로 기본 생성자를 만들어준다. 그래서 오류가 발생하지 않는다.
```java
class Parent {  
    Parent(int num){  
    // 아무 입력이 없으면 super(); 자동 입력
    // 기본 생성자가 없으므로 오류 발생
    }  
}  
  
class Child extends Parent{  
    Child(){  
        // 아무 입력이 없으면 super(); 자동 입력  
    }  
}
```
위 코드는 Parent 클래스에 기본 생성자가 아닌 생성자를 하나 추가한 코드다. 생성자가 있으므로 기본 생성자를 자동을 입력해주지 않고 그래서 오류가 발생한다.

&nbsp;
## package
___
서로 연관된 클래스의 묶음이다. 클래스의 이름은 실제로 패키지를 포함한다. 그래서 클래스의 이름이 같더라도 다른 패키지에 있으면 구분이 가능하다. 
#### import
클래스를 사용할 때 패키지 이름을 생략할 수 있게 해준다. java.lang은 기본적인 패키지므로 import 없어도 패키지명 없이 사용이 가능하다.
```java
// import 없는 경우
// 메서드의 패키지명까지 입력해야함.
java.util.Arrays.toString(arr);

// import 하는 경우
// 패키지명 생략 가능
import java.util.Arrays;

Arrays.toString(arr);

```

&nbsp;
## 제어자
___
클래스와 멤버에 부가적인 의미를 부여하는 역할을 한다. 접근 제어자를 제외하고는 제어자를 여려개 사용할 수 있다.
1. static

멤버변수와 메서드에 사용이 가능하다.
멤버변수 : 인스턴스에 공통적으로 사용되는 변수가 된다.
메서드 : 인스턴스를 생성하지 않고도 호출이 가능하다.

2. final

클래스,메서드,멤버변수,지역변수에 사용이 가능하다.
클래스 : 다른 클래스의 조상이 될 수 없다.
메서드 : 오버라이딩이 불가능하다.
변수 : 값을 변경할 수 없다. (상수)

3. abstract
클래스, 메서드에 사용이 가능하다.
클래스 : 추상메서드임을 알린다.
메서드 : 구현부는 없는 추상 메서드임을 알린다.

#### 접근 제어자
멤버 또는 클래스에 사용되며 접근에대한 범위를 정한다. 주로 선언부 가장 왼쪽에 위치한다.
private : 같은 클래스끼리만 접근 가능.
(default) : 접근 제어자를 선언하지 않으면 default 제어자로 인식됨. 같은 패키지 내에서만 접근 가능.
protected : 같은 패키지 + 다른 패키지의 자손까지 접근 가능.
public : 접근 제한 없음.

&nbsp;
## 캡슐화
___
위의 접근 제어자를 사용하는 이유는 외부로부터 데이터를 보호하고 외부로 노출될 필요가 없는 것들을 감추기 위해서다. 이렇게 데이터를 보호하는 것을 **캡슐화**라고 한다. 외부에 노출될 필요가 없는 변수들은 private으로 선언하고 값을 확인하거나 변경하려면 public한 getter, setter 메서드를 이용해서 접근이 가능하다.

&nbsp;
## 다형성
___
조상 타입의 참조변수로 자손 타입의 객체를 다루는 것을 의미한다. 조상 타입을 참조변수로 다루기 때문에 자손 클래스에만 존재하는 변수나 메서드를 사용하는 것은 불가능하다.
#### 다형성의 형변환
다형성의 형변환을 통해서 인스턴스를 참조하는 타입을 변경할 수 있다. 상속관계에 있는 참조변수는 서로 형변환이 가능하다.
- 생성된 인스턴스보다 자손인 타입으로는 형변환이 불가능하다.
- 현재 참조 타입보다 조상 타입으로 형변환을 하는 경우에는 형변환을 생략할 수 있지만 자손 타입으로 형변환을 하는 경우에는 생략이 불가능하다.

> A instanceOf B

A객체가 B로부터 상속을 받았는지 여부를 확인할 수 있다. 이 조건이 true가 나온다면 A객체는 B로 형변환을 할 수 있다.
#### 매개변수의 다형성
참조형 매개변수는 자신이나 자손 타입의 인스턴스를 넘겨준다.

&nbsp;
## 추상 클래스
___
미완성된 추상 메서드를 포함하고 있는 클래스다. 미완성 메서드가 존재하므로 추상 클래스는 객체를 형성할 수 없다. 추상 클래스를 상속받은 자손 클래스는 추상 메서드를 오버라이딩해서 완성시켜야 한다. 만약 상속받은 클래스가 추상 메서드를 완성하지 않으면 그 자손 클래스도 추상 클래스로 선언해야 한다. 

&nbsp;
## 인터페이스
___
메서드는 추상 메서드만 존재하고 변수는 상수만 가능하다. 모든 멤버의 접근 제어자가 public이다. 인터페이스도 인터페이스끼리 상속이 가능한데 클래스의 상속과 다른점은 다중상속이 가능하다는 점이다. 그리고 추상 클래스와 마찬가지로 인터페이스는 추상 메서드를 가지고 있으므로 그 자체로는 인스턴스를 형성할 수 없다. 그래서 다른 클래스에 의존하게 되는데 클래스의 상속처럼 인터페이스는 구현이라고 한다. 인터페이스를 구현받은 클래스는 추상 메서드를 완성시켜야 한다. 그렇지 않으면 추상 메서드와 마찬가지로 구현받은 클래스도 추상 클래스가 된다.
#### 인터페이스의 다형성
인터페이스도 다형성이 가능하고 인터페이스 참조 변수는 구현 받은 클래스의 객체를 참조할 수 있다. 매개변수도 마찬가지로 인터페이스가 참조한 객체를 입력값으로 넘겨준다.

오버라이딩을 하는 이유
오버라이딩의 오류와 제어자 제한 이유?
다형성을 사용하는 이유?
